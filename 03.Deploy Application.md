
<img width="1161" height="561" alt="image" src="https://github.com/user-attachments/assets/2cc28d13-73ae-4c4c-b45f-6fe51471ffe9" />


# How to Deploy Application on OpenShift via WEBGUI




<img width="1160" height="658" alt="image" src="https://github.com/user-attachments/assets/06a920da-c674-42ed-b635-d905feafacbf" />




# How to Deploy Application on OpenShift via CLI 

## Commands --  

https://claude.ai/chat/94fc82d9-67af-48f7-8620-5f40f521a784


oc new-app --name my-nginx registry.redhat.io/nginxinc/nginx-unprivileged 

# Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'


  # Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Deploy the PostgreSQL image with a name and set environment variables.
oc new-app --name my-postgres --docker-image docker.io/library/postgres:15 \
  -e POSTGRES_USER=myuser \
  -e POSTGRES_PASSWORD=mypassword \
  -e POSTGRES_DB=mydb

oc new-project chapter1  

podman pull quay.io/redhattraining/todo-angular

docker pull quay.io/redhattraining/todo-angular

oc new-app --name hello1 quay.io/redhattraining/todo-angular

oc new-app --name hello --image quay.io/redhattraining/hello-world-nginx:v1.0  


<img width="832" height="357" alt="image" src="https://github.com/user-attachments/assets/b4bdde73-9e90-4edc-82a8-d2aaaa19c748" />

oc get all  

<img width="837" height="290" alt="image" src="https://github.com/user-attachments/assets/67291901-6f0c-41bf-aff0-3f6fcebfb1d1" />

oc expose service hello  

oc get all  


<img width="822" height="373" alt="image" src="https://github.com/user-attachments/assets/97caca60-5064-4de9-84e0-ad10640d15ec" />


<img width="852" height="440" alt="image" src="https://github.com/user-attachments/assets/8fcd06d4-d9b3-4f56-a8cf-98ae17d73e3b" />




oc get pod -o wide  

<img width="828" height="387" alt="image" src="https://github.com/user-attachments/assets/73528c13-602c-4b91-93a6-b2b5961bc110" />

<img width="822" height="475" alt="image" src="https://github.com/user-attachments/assets/15b08c81-d49a-459d-be0f-a5d0c20d6c86" />



oc scale --replicas 4 deployment/hello  

<img width="827" height="455" alt="image" src="https://github.com/user-attachments/assets/2d269218-0f66-4ec1-bc0d-c9cd7f723b35" />





oc delete project chapter1

<img width="822" height="296" alt="image" src="https://github.com/user-attachments/assets/5c809bc4-9093-452b-b974-d9fc38b7eb01" />



Absolutely! Let’s break this down clearly. **Source-to-Image (S2I)** is a **key OpenShift feature** that simplifies building container images from source code.

---

## **1. What is Source-to-Image (S2I)?**

* **S2I** is a **tool and workflow** in OpenShift that takes your **application source code** and automatically produces a **ready-to-run Docker (container) image**.
* It combines **source code + builder image** → produces a **new runnable image**.
* This image can then be deployed directly using a **DeploymentConfig**.

---

### **Key Components**

1. **Source Code**

   * Your application code, usually in GitHub/GitLab or local archive.
   * Can be any language supported by builder images (Java, Python, Node.js, Go, etc.).

2. **Builder Image**

   * A base image that contains runtime, language tools, and build scripts.
   * OpenShift has official S2I builder images like `python:3.11`, `nodejs:20`, `openjdk-17`.

3. **S2I Scripts**

   * The builder image contains scripts that tell OpenShift **how to build the source, assemble it, and run it**.

---

## **2. How S2I works – Workflow**

1. OpenShift pulls the **builder image**.
2. OpenShift pulls your **source code** from Git (or local archive).
3. S2I **combines the two**:

   * Compiles/builds the source (if needed).
   * Installs dependencies.
   * Assembles a runnable container image.
4. The resulting image is pushed to the **internal OpenShift registry**.
5. You can deploy it immediately using a **DeploymentConfig**.

---

### **3. Commands in OpenShift**

* **Create an app using S2I:**

```bash
oc new-app <builder-image>~<git-repo-url> --name=myapp
```

Example:

```bash
oc new-app python:3.11~https://github.com/myuser/myapp.git --name=myapp
```

* **Check BuildConfig created:**

```bash
oc get bc
oc describe bc myapp
```

* **Check ImageStream created:**

```bash
oc get is
oc describe is myapp
```

* **Check DeploymentConfig created:**

```bash
oc get dc
oc describe dc myapp
```

✅ Note: Using `oc new-app` with S2I usually **creates 3 objects automatically**:

1. **BuildConfig (BC)** – builds image from source
2. **ImageStream (IS)** – tracks the image
3. **DeploymentConfig (DC)** – deploys the app

---

### **4. Advantages of S2I**

* **No need to write Dockerfiles** (unless you want customizations).
* **Automatic image updates** when source code changes.
* **Integration with OpenShift CI/CD** – BuildConfigs trigger builds, ImageStreams trigger deployments.
* **Supports multiple languages** with official builder images.

---

### **5. Example Scenario**

1. Developer pushes code to GitHub.
2. OpenShift BuildConfig detects new commit (via webhook).
3. BuildConfig triggers a **S2I build** → new image created in internal registry.
4. DeploymentConfig with **ImageChange trigger** automatically deploys pods using the new image.

---

✅ **Key takeaway**:
**Source-to-Image (S2I) = Automatic way to convert source code + runtime image → runnable container image**.

---


---

## **1. What is S2I (Source-to-Image)?**

**S2I** is a tool in OpenShift that **builds reproducible Docker images directly from source code**. It’s an OpenShift-native way to take your application source and turn it into a runnable container image.

* **Goal:** Automatically create a Docker image from your source code.
* **Key Benefit:** Developers don’t need to write a Dockerfile manually.

---

## **2. How S2I Works**

S2I combines **source code** + **builder image** → **ready-to-run image**.

**Steps:**

1. **Select a Builder Image**
   OpenShift provides pre-built builder images, e.g., `python`, `nodejs`, `java`, `dotnet`.

2. **Add Application Source Code**
   S2I takes your code (from Git repo or local source).

3. **Assemble & Build Image**

   * The builder image contains scripts that know how to **compile your code**, **install dependencies**, and **prepare runtime environment**.
   * S2I runs these scripts and produces a new container image.

4. **Deploy the Application**
   The newly built image is deployed as a pod in OpenShift.

---

## **3. S2I Deployment Process in OpenShift**

Here’s a typical workflow:

1. **Create a Project**

   ```bash
   oc new-project my-app
   ```

2. **Start a New S2I Build**

   ```bash
   oc new-app python:3.11~https://github.com/myrepo/myapp.git --name=myapp
   ```

   * `python:3.11` → Builder image
   * `~https://github.com/...` → Source code repo
   * `--name=myapp` → Name of the app

3. **Monitor Build**

   ```bash
   oc get builds
   oc logs build/myapp-1
   ```

4. **Deploy**
   OpenShift automatically deploys the built image as a **DeploymentConfig → Pods**.

5. **Access Application**

   ```bash
   oc expose svc/myapp
   ```

   * Creates a route for external access.

---

## **4. Key Components in S2I Deployment**

| Component            | Description                                                              |
| -------------------- | ------------------------------------------------------------------------ |
| **Builder Image**    | Pre-configured image for a language/runtime (Python, NodeJS, Java, etc.) |
| **Source Code**      | Your app code repository                                                 |
| **S2I Scripts**      | Assemble, run, and environment scripts inside the builder image          |
| **DeploymentConfig** | OpenShift resource that deploys the new image                            |
| **Pod**              | Running instance of your app                                             |

---


In **OpenShift**, the `--strategy` option is used when creating a new application or build to **specify the build strategy**—basically, how OpenShift should build your application into a container image.

When using **S2I (Source-to-Image)**, the `--strategy` flag tells OpenShift to use S2I as the build mechanism.

---

### **Usage of `--strategy`**

```bash
oc new-app <builder-image>~<source-code-repo> --name=<app-name> --strategy=<build-strategy>
```

* `<build-strategy>` can be:

  1. **`source`** → S2I build (default if builder image is specified)
  2. **`docker`** → Standard Dockerfile build
  3. **`custom`** → Use a custom build image

---

### **Example with S2I**

```bash
oc new-app python:3.11~https://github.com/myrepo/myapp.git --name=myapp --strategy=source
```

**Explanation:**

* `python:3.11` → Builder image
* `https://github.com/myrepo/myapp.git` → Application source
* `--strategy=source` → Use S2I to assemble the image

> Note: If you don’t provide `--strategy=source`, OpenShift automatically uses S2I **if you specify a builder image**.

---

### **Comparison of Build Strategies**

| Strategy   | Description                                                   |
| ---------- | ------------------------------------------------------------- |
| **source** | Builds the app using **S2I**, combines source + builder image |
| **docker** | Builds the app using a **Dockerfile** provided in the repo    |
| **custom** | Uses a **custom build image** to produce the final image      |

---

✅ **Key Point:**
`--strategy=source` explicitly tells OpenShift to perform a **Source-to-Image build**, which is ideal when you have a builder image and want OpenShift to handle the image assembly automatically.

---

If you want, I can also explain **how `--strategy` affects incremental builds in S2I**—it’s quite useful for faster deployments. Do you want me to cover that?
