
<img width="1161" height="561" alt="image" src="https://github.com/user-attachments/assets/2cc28d13-73ae-4c4c-b45f-6fe51471ffe9" />


# How to Deploy Application on OpenShift via WEBGUI




<img width="1160" height="658" alt="image" src="https://github.com/user-attachments/assets/06a920da-c674-42ed-b635-d905feafacbf" />




# How to Deploy Application on OpenShift via CLI 

## Commands --  

https://claude.ai/chat/94fc82d9-67af-48f7-8620-5f40f521a784


oc new-app --name my-nginx registry.redhat.io/nginxinc/nginx-unprivileged 

# Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'


  # Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Deploy the PostgreSQL image with a name and set environment variables.
oc new-app --name my-postgres --docker-image docker.io/library/postgres:15 \
  -e POSTGRES_USER=myuser \
  -e POSTGRES_PASSWORD=mypassword \
  -e POSTGRES_DB=mydb

oc new-project chapter1  

podman pull quay.io/redhattraining/todo-angular

docker pull quay.io/redhattraining/todo-angular

oc new-app --name hello1 quay.io/redhattraining/todo-angular

oc new-app --name hello --image quay.io/redhattraining/hello-world-nginx:v1.0  


<img width="832" height="357" alt="image" src="https://github.com/user-attachments/assets/b4bdde73-9e90-4edc-82a8-d2aaaa19c748" />

oc get all  

<img width="837" height="290" alt="image" src="https://github.com/user-attachments/assets/67291901-6f0c-41bf-aff0-3f6fcebfb1d1" />

oc expose service hello  

oc get all  


<img width="822" height="373" alt="image" src="https://github.com/user-attachments/assets/97caca60-5064-4de9-84e0-ad10640d15ec" />


<img width="852" height="440" alt="image" src="https://github.com/user-attachments/assets/8fcd06d4-d9b3-4f56-a8cf-98ae17d73e3b" />




oc get pod -o wide  

<img width="828" height="387" alt="image" src="https://github.com/user-attachments/assets/73528c13-602c-4b91-93a6-b2b5961bc110" />

<img width="822" height="475" alt="image" src="https://github.com/user-attachments/assets/15b08c81-d49a-459d-be0f-a5d0c20d6c86" />



oc scale --replicas 4 deployment/hello  

<img width="827" height="455" alt="image" src="https://github.com/user-attachments/assets/2d269218-0f66-4ec1-bc0d-c9cd7f723b35" />





oc delete project chapter1

<img width="822" height="296" alt="image" src="https://github.com/user-attachments/assets/5c809bc4-9093-452b-b974-d9fc38b7eb01" />



Absolutely! Let’s break this down clearly. **Source-to-Image (S2I)** is a **key OpenShift feature** that simplifies building container images from source code.

---

## **1. What is Source-to-Image (S2I)?**

* **S2I** is a **tool and workflow** in OpenShift that takes your **application source code** and automatically produces a **ready-to-run Docker (container) image**.
* It combines **source code + builder image** → produces a **new runnable image**.
* This image can then be deployed directly using a **DeploymentConfig**.

---

### **Key Components**

1. **Source Code**

   * Your application code, usually in GitHub/GitLab or local archive.
   * Can be any language supported by builder images (Java, Python, Node.js, Go, etc.).

2. **Builder Image**

   * A base image that contains runtime, language tools, and build scripts.
   * OpenShift has official S2I builder images like `python:3.11`, `nodejs:20`, `openjdk-17`.

3. **S2I Scripts**

   * The builder image contains scripts that tell OpenShift **how to build the source, assemble it, and run it**.

---

## **2. How S2I works – Workflow**

1. OpenShift pulls the **builder image**.
2. OpenShift pulls your **source code** from Git (or local archive).
3. S2I **combines the two**:

   * Compiles/builds the source (if needed).
   * Installs dependencies.
   * Assembles a runnable container image.
4. The resulting image is pushed to the **internal OpenShift registry**.
5. You can deploy it immediately using a **DeploymentConfig**.

---

### **3. Commands in OpenShift**

* **Create an app using S2I:**

```bash
oc new-app <builder-image>~<git-repo-url> --name=myapp
```

Example:

```bash
oc new-app python:3.11~https://github.com/myuser/myapp.git --name=myapp
```

* **Check BuildConfig created:**

```bash
oc get bc
oc describe bc myapp
```

* **Check ImageStream created:**

```bash
oc get is
oc describe is myapp
```

* **Check DeploymentConfig created:**

```bash
oc get dc
oc describe dc myapp
```

✅ Note: Using `oc new-app` with S2I usually **creates 3 objects automatically**:

1. **BuildConfig (BC)** – builds image from source
2. **ImageStream (IS)** – tracks the image
3. **DeploymentConfig (DC)** – deploys the app

---

### **4. Advantages of S2I**

* **No need to write Dockerfiles** (unless you want customizations).
* **Automatic image updates** when source code changes.
* **Integration with OpenShift CI/CD** – BuildConfigs trigger builds, ImageStreams trigger deployments.
* **Supports multiple languages** with official builder images.

---

### **5. Example Scenario**

1. Developer pushes code to GitHub.
2. OpenShift BuildConfig detects new commit (via webhook).
3. BuildConfig triggers a **S2I build** → new image created in internal registry.
4. DeploymentConfig with **ImageChange trigger** automatically deploys pods using the new image.

---

✅ **Key takeaway**:
**Source-to-Image (S2I) = Automatic way to convert source code + runtime image → runnable container image**.

---


---

## **1. What is S2I (Source-to-Image)?**

**S2I** is a tool in OpenShift that **builds reproducible Docker images directly from source code**. It’s an OpenShift-native way to take your application source and turn it into a runnable container image.

* **Goal:** Automatically create a Docker image from your source code.
* **Key Benefit:** Developers don’t need to write a Dockerfile manually.

---

## **2. How S2I Works**

S2I combines **source code** + **builder image** → **ready-to-run image**.

**Steps:**

1. **Select a Builder Image**
   OpenShift provides pre-built builder images, e.g., `python`, `nodejs`, `java`, `dotnet`.

2. **Add Application Source Code**
   S2I takes your code (from Git repo or local source).

3. **Assemble & Build Image**

   * The builder image contains scripts that know how to **compile your code**, **install dependencies**, and **prepare runtime environment**.
   * S2I runs these scripts and produces a new container image.

4. **Deploy the Application**
   The newly built image is deployed as a pod in OpenShift.

---

## **3. S2I Deployment Process in OpenShift**

Here’s a typical workflow:

1. **Create a Project**

   ```bash
   oc new-project my-app
   ```

2. **Start a New S2I Build**

   ```bash
   oc new-app python:3.11~https://github.com/myrepo/myapp.git --name=myapp
   ```

   * `python:3.11` → Builder image
   * `~https://github.com/...` → Source code repo
   * `--name=myapp` → Name of the app

3. **Monitor Build**

   ```bash
   oc get builds
   oc logs build/myapp-1
   ```

4. **Deploy**
   OpenShift automatically deploys the built image as a **DeploymentConfig → Pods**.

5. **Access Application**

   ```bash
   oc expose svc/myapp
   ```

   * Creates a route for external access.

---

## **4. Key Components in S2I Deployment**

| Component            | Description                                                              |
| -------------------- | ------------------------------------------------------------------------ |
| **Builder Image**    | Pre-configured image for a language/runtime (Python, NodeJS, Java, etc.) |
| **Source Code**      | Your app code repository                                                 |
| **S2I Scripts**      | Assemble, run, and environment scripts inside the builder image          |
| **DeploymentConfig** | OpenShift resource that deploys the new image                            |
| **Pod**              | Running instance of your app                                             |

---


In **OpenShift**, the `--strategy` option is used when creating a new application or build to **specify the build strategy**—basically, how OpenShift should build your application into a container image.

When using **S2I (Source-to-Image)**, the `--strategy` flag tells OpenShift to use S2I as the build mechanism.

---

### **Usage of `--strategy`**

```bash
oc new-app <builder-image>~<source-code-repo> --name=<app-name> --strategy=<build-strategy>
```

* `<build-strategy>` can be:

  1. **`source`** → S2I build (default if builder image is specified)
  2. **`docker`** → Standard Dockerfile build
  3. **`custom`** → Use a custom build image

---

### **Example with S2I**

```bash
oc new-app python:3.11~https://github.com/myrepo/myapp.git --name=myapp --strategy=source
```

**Explanation:**

* `python:3.11` → Builder image
* `https://github.com/myrepo/myapp.git` → Application source
* `--strategy=source` → Use S2I to assemble the image

> Note: If you don’t provide `--strategy=source`, OpenShift automatically uses S2I **if you specify a builder image**.

---

### **Comparison of Build Strategies**

| Strategy   | Description                                                   |
| ---------- | ------------------------------------------------------------- |
| **source** | Builds the app using **S2I**, combines source + builder image |
| **docker** | Builds the app using a **Dockerfile** provided in the repo    |
| **custom** | Uses a **custom build image** to produce the final image      |

---

✅ **Key Point:**
`--strategy=source` explicitly tells OpenShift to perform a **Source-to-Image build**, which is ideal when you have a builder image and want OpenShift to handle the image assembly automatically.

---

Deploying applications to a Red Hat OpenShift cluster can be done in various ways, with the `oc` command-line tool being the primary interface. The following outlines the step-by-step procedure for each deployment method you listed, including command explanations and verification steps.

-----

### 1\. From Developer Code (Local Directory)

This method uses Source-to-Image (S2I) to build and deploy a container image directly from source code on your local machine.

  * **Deployment:** First, log in to OpenShift and navigate to the directory containing your code.

    ```bash
    oc new-app . --name=myapp-s2i
    ```

    The `oc new-app` command with a `.` argument tells OpenShift to initiate an S2I build using the code in your current directory. It automatically detects the language and creates a `DeploymentConfig` and a `Service`.

  * **Verify Deployment:**

    ```bash
    oc status
    ```

    This command provides a summary of the project, showing the status of the build and the deployment.

  * **Verify PODs Creation:**

    ```bash
    oc get pods -o wide
    ```

    The `-o wide` flag provides detailed information about the pod, including its `IP` address and the `NODE` it's running on. This is useful for troubleshooting and network verification.

  * **Show Services:**

    ```bash
    oc get services
    ```

    This command lists the `Service` that was automatically created, which provides a stable internal IP address for your application.

  * **Create and Show Routes:**

    ```bash
    oc expose svc/myapp-s2i
    oc get routes
    ```

    The `oc expose` command creates a `Route` to expose your application to external traffic, and `oc get routes` shows the public URL (hostname) for the application.

-----

### 2\. From Code in GitHub

This is a common GitOps approach where OpenShift fetches source code from a Git repository, builds it into an image, and then deploys it.

  * **Deployment:**

    ```bash
    oc new-app https://github.com/openshift/nodejs-ex.git --name=nodejs-git-app
    ```

    `oc new-app` fetches the code from the specified Git repository and uses an S2I builder to create and deploy the application.

  * **Verify Deployment:**

    ```bash
    oc status
    ```

    This shows the status of the `BuildConfig`, the deployment, and the pods.

  * **Verify PODs Creation:**

    ```bash
    oc get pods -o wide
    ```

    Once the build is complete and the deployment is finished, this command will show a running pod for your application, along with its details.

  * **Show Services:**

    ```bash
    oc get services
    ```

    This lists the `Service` created to manage the pod's network access within the cluster.

  * **Create and Show Routes:**

    ```bash
    oc expose svc/nodejs-git-app
    oc get routes
    ```

    `oc expose` creates a route for the service, and `oc get routes` displays its hostname, allowing external access.

-----

### 3\. From a Docker file

This process involves building a container image from a `Dockerfile` and pushing it to OpenShift's internal registry, then deploying from there.

  * **Deployment:**

    ```bash
    oc new-build --binary --name=my-app-image --strategy=docker
    oc start-build my-app-image --from-dir=. --follow
    ```

    The `oc new-build` command creates a `BuildConfig` using the `Dockerfile` strategy. The `oc start-build` command then builds the image from the contents of the local directory (`--from-dir=.`) and pushes it to the internal registry.

  * **Verify Deployment:** The build process itself serves as the first verification step, and `oc status` will confirm the build's success. Once the image is ready, you can deploy it:

    ```bash
    oc new-app my-app-image --name=my-app-deploy
    ```

    This command creates a deployment from the newly built image in the internal registry.

  * **Verify PODs Creation:**

    ```bash
    oc get pods -o wide
    ```

    This confirms the successful creation and running status of the pod.

  * **Show Services:**

    ```bash
    oc get services
    ```

    This displays the service that provides a stable internal IP for your deployed application.

  * **Create and Show Routes:**

    ```bash
    oc expose svc/my-app-deploy
    oc get routes
    ```

    This exposes the application to the outside world and shows its public URL.

-----

### 4\. From External Registry (docker.io or quay.io)

This is the simplest deployment method when you already have a pre-built container image in a public registry.

  * **Deployment:**

    ```bash
    oc new-app --docker-image=docker.io/nginx --name=nginx-ext
    ```

    The `--docker-image` flag tells OpenShift to pull a specific image (`nginx`) from the `docker.io` registry. OpenShift automatically creates a `DeploymentConfig` and pulls the image.

  * **Verify Deployment:**

    ```bash
    oc status
    ```

    This will show the deployment's progress as it pulls the image and starts the pod.

  * **Verify PODs Creation:**

    ```bash
    oc get pods -o wide
    ```

    This confirms that a pod has been created and is running, and shows its IP address and location.

  * **Show Services:**

    ```bash
    oc get services
    ```

    This lists the `ClusterIP` Service that was automatically created to provide internal networking for your application.

  * **Create and Show Routes:**

    ```bash
    oc expose svc/nginx-ext
    oc get routes
    ```

    This command exposes the application via a route, and then lists the route's hostname, allowing you to access the Nginx web server from your browser.
