
<img width="1161" height="561" alt="image" src="https://github.com/user-attachments/assets/2cc28d13-73ae-4c4c-b45f-6fe51471ffe9" />


# How to Deploy Application on OpenShift via WEBGUI




<img width="1160" height="658" alt="image" src="https://github.com/user-attachments/assets/06a920da-c674-42ed-b635-d905feafacbf" />




# How to Deploy Application on OpenShift via CLI 

## Commands --  

https://claude.ai/chat/94fc82d9-67af-48f7-8620-5f40f521a784


oc new-app --name my-nginx registry.redhat.io/nginxinc/nginx-unprivileged 

# Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'


  # Deploy the Node.js image with a custom command
oc new-app --name my-nodejs-app --docker-image docker.io/library/node:18 \
  --entrypoint /bin/bash \
  -- sh -c 'echo "Hello from OpenShift!" > /tmp/index.html && http-server /tmp'

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Expose the application to the internet
oc expose service my-nodejs-app --port 8080

# Deploy the PostgreSQL image with a name and set environment variables.
oc new-app --name my-postgres --docker-image docker.io/library/postgres:15 \
  -e POSTGRES_USER=myuser \
  -e POSTGRES_PASSWORD=mypassword \
  -e POSTGRES_DB=mydb

oc new-project chapter1  

podman pull quay.io/redhattraining/todo-angular

docker pull quay.io/redhattraining/todo-angular

oc new-app --name hello1 quay.io/redhattraining/todo-angular

oc new-app --name hello --image quay.io/redhattraining/hello-world-nginx:v1.0  


<img width="832" height="357" alt="image" src="https://github.com/user-attachments/assets/b4bdde73-9e90-4edc-82a8-d2aaaa19c748" />

oc get all  

<img width="837" height="290" alt="image" src="https://github.com/user-attachments/assets/67291901-6f0c-41bf-aff0-3f6fcebfb1d1" />

oc expose service hello  

oc get all  


<img width="822" height="373" alt="image" src="https://github.com/user-attachments/assets/97caca60-5064-4de9-84e0-ad10640d15ec" />


<img width="852" height="440" alt="image" src="https://github.com/user-attachments/assets/8fcd06d4-d9b3-4f56-a8cf-98ae17d73e3b" />




oc get pod -o wide  

<img width="828" height="387" alt="image" src="https://github.com/user-attachments/assets/73528c13-602c-4b91-93a6-b2b5961bc110" />

<img width="822" height="475" alt="image" src="https://github.com/user-attachments/assets/15b08c81-d49a-459d-be0f-a5d0c20d6c86" />



oc scale --replicas 4 deployment/hello  

<img width="827" height="455" alt="image" src="https://github.com/user-attachments/assets/2d269218-0f66-4ec1-bc0d-c9cd7f723b35" />





oc delete project chapter1

<img width="822" height="296" alt="image" src="https://github.com/user-attachments/assets/5c809bc4-9093-452b-b974-d9fc38b7eb01" />



Absolutely! Let’s break this down clearly. **Source-to-Image (S2I)** is a **key OpenShift feature** that simplifies building container images from source code.

---

## **1. What is Source-to-Image (S2I)?**

* **S2I** is a **tool and workflow** in OpenShift that takes your **application source code** and automatically produces a **ready-to-run Docker (container) image**.
* It combines **source code + builder image** → produces a **new runnable image**.
* This image can then be deployed directly using a **DeploymentConfig**.

---

### **Key Components**

1. **Source Code**

   * Your application code, usually in GitHub/GitLab or local archive.
   * Can be any language supported by builder images (Java, Python, Node.js, Go, etc.).

2. **Builder Image**

   * A base image that contains runtime, language tools, and build scripts.
   * OpenShift has official S2I builder images like `python:3.11`, `nodejs:20`, `openjdk-17`.

3. **S2I Scripts**

   * The builder image contains scripts that tell OpenShift **how to build the source, assemble it, and run it**.

---

## **2. How S2I works – Workflow**

1. OpenShift pulls the **builder image**.
2. OpenShift pulls your **source code** from Git (or local archive).
3. S2I **combines the two**:

   * Compiles/builds the source (if needed).
   * Installs dependencies.
   * Assembles a runnable container image.
4. The resulting image is pushed to the **internal OpenShift registry**.
5. You can deploy it immediately using a **DeploymentConfig**.

---

### **3. Commands in OpenShift**

* **Create an app using S2I:**

```bash
oc new-app <builder-image>~<git-repo-url> --name=myapp
```

Example:

```bash
oc new-app python:3.11~https://github.com/myuser/myapp.git --name=myapp
```

* **Check BuildConfig created:**

```bash
oc get bc
oc describe bc myapp
```

* **Check ImageStream created:**

```bash
oc get is
oc describe is myapp
```

* **Check DeploymentConfig created:**

```bash
oc get dc
oc describe dc myapp
```

✅ Note: Using `oc new-app` with S2I usually **creates 3 objects automatically**:

1. **BuildConfig (BC)** – builds image from source
2. **ImageStream (IS)** – tracks the image
3. **DeploymentConfig (DC)** – deploys the app

---

### **4. Advantages of S2I**

* **No need to write Dockerfiles** (unless you want customizations).
* **Automatic image updates** when source code changes.
* **Integration with OpenShift CI/CD** – BuildConfigs trigger builds, ImageStreams trigger deployments.
* **Supports multiple languages** with official builder images.

---

### **5. Example Scenario**

1. Developer pushes code to GitHub.
2. OpenShift BuildConfig detects new commit (via webhook).
3. BuildConfig triggers a **S2I build** → new image created in internal registry.
4. DeploymentConfig with **ImageChange trigger** automatically deploys pods using the new image.

---

✅ **Key takeaway**:
**Source-to-Image (S2I) = Automatic way to convert source code + runtime image → runnable container image**.

---

If you want, I can make a **diagram showing S2I flow**: **Source Code + Builder Image → BuildConfig → ImageStream → DeploymentConfig → Pods**, which makes it very easy to visualize.

Do you want me to make that diagram?

